/*
 * Generated by MyEclipse Struts
 * Template path: templates/java/JavaClass.vtl
 */
package com.yourcompany.struts.action;

import java.io.IOException;
import java.io.PrintWriter;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import javax.activation.DataSource;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.struts.action.Action;
import org.apache.struts.action.ActionForm;
import org.apache.struts.action.ActionForward;
import org.apache.struts.action.ActionMapping;

import utool.DateTool;

import com.yourcompany.struts.form.PurchaseForm;


/**
 * MyEclipse Struts Creation date: 03-23-2013
 * 
 * XDoclet definition:
 * 
 * @struts.action path="/purchase" name="purchaseForm" input="/purchase.jsp"
 *                scope="request"
 */
public class PurchaseAction extends Action {
	private Connection conn = null;

	/*
	 * Generated Methods
	 */

	/**
	 * Method execute
	 * 
	 * @param mapping
	 * @param form
	 * @param request
	 * @param response
	 * @return ActionForward
	 */
	
	public ActionForward execute(ActionMapping mapping, ActionForm form,
			HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		String url = "jdbc:Mysql://localhost:3306/";
		String dbName = "firststruts";
		String driver = "com.mysql.jdbc.Driver";
		String userName = "root";
		String password = "123456";
		response.setContentType("text/html;charset=UTF-8");
		String purchaseRes="purchaseFail";

		try {
			Class.forName(driver).newInstance();
			conn = DriverManager
					.getConnection(url + dbName, userName, password);
		} catch (InstantiationException ie) {
			ie.printStackTrace();
		} catch (IllegalAccessException iae) {
			iae.printStackTrace();
		} catch (ClassNotFoundException cnfe) {
			cnfe.printStackTrace();
		} catch (SQLException se) {
			se.printStackTrace();
		}

		try {
			int secNum = 4;

			String userID = null;
			Cookie[] cookies=request.getCookies();
			for(int i=0;i<cookies.length;i++){
                if(cookies[i].getName().equals("userID"))
                userID=cookies[i].getValue();
               }
			//String userID =(String)session.getAttribute("userID");
			
			if(userID==null){
				System.out.println("No userID");
			}else{
				System.out.println(userID+"~~~~~~~~~~~~~~~~~~~~~~~~~~~");
				java.sql.PreparedStatement prepStmt = null;
				
				String section = request.getParameter("section");
				String startdate = request.getParameter("startdate");
				String expiredate = request.getParameter("expiredate");
				
				Date subStrDate = null;
				Date subExpDate = null;

				Date startTime = null;
				Date expireTime = null;
				Date curDate = new Date();
				ResultSet rsPurchase;
				String errMsg = "The purchase is not valid.\n";
				long msToD = 86400000;
				
				if(section==""||startdate==""||expiredate==""){
					errMsg += "Subscription Failure Reason: insufficient subscription information\n";
				}else{
					subStrDate = DateTool.getDate(startdate);
					subExpDate = DateTool.getDate(expiredate);
					
					if(subStrDate.getTime()>subExpDate.getTime()){
						errMsg += "Subscription Failure Reason: the endDate is before or the same as startDate\n";
					}else if(subStrDate.getTime()<(curDate.getTime()-msToD)){
						errMsg += "Subscription Failure Reason: the startDate is before the curDate\n";
					}else if(subExpDate.getTime()<(curDate.getTime()-msToD)){
						errMsg += "Subscription Failure Reason: the endDate is before the curDate\n";
					}else{
						//The subscription expire date really means expire the day after that date
						Calendar calendar = Calendar.getInstance();
						calendar.setTime(subExpDate);
						calendar.add(Calendar.DATE, 1);
						subExpDate = calendar.getTime();
						
						SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
						expiredate = sdf.format(subExpDate);
						
						/*
						 * Check with the record
						 * There are at most 6 possibilities:
						 * While the subscription start date is before the record start date,
						 * the subscription expire date can be before the record start date (1), between the recored start date and recored expire date (2), or after the recored expire date (3)
						 * While the subscription start date is between the record start date and recored expire date,
						 * the subscription expire date can before (4) or after the record expire date (5)
						 * While the subscription start date is after the record expire date
						 * the subscription expire date can only be after the record expire date (6)
						 * Only possibilities 1 and 6 is totally legal
						 */
						boolean vldP = true;	//Since this might be the first subscription of the user, we set the default to be true
						
						String sql = "select * from purchaseinfo where userID=? and section= ?";
						prepStmt = conn.prepareStatement(sql);
						prepStmt.setString(1, userID);
						prepStmt.setString(2, section);
						rsPurchase = prepStmt.executeQuery();
						errMsg = "Conflict with previous subscription record.\n";
						
						int j = 1;
						while(rsPurchase.next()){
							startTime = rsPurchase.getDate("starttime");
							expireTime = rsPurchase.getDate("expiretime");
							
							if(startTime.getTime()>subStrDate.getTime()){
								if(startTime.getTime()>subExpDate.getTime()){
									//Possibility 1
								}else{
									if(expireTime.getTime()<subExpDate.getTime()){
										//Possibility 3
										vldP = false;
										errMsg += "Conflict "+j+", type 3: You have already purchased from "+startTime+" to "+expireTime+";\n";
										j++;
									}else{
										//Possibility 2
										vldP = false;
										errMsg += "Conflict "+j+", type 2: You have already purchased from "+startTime+" to "+expireTime+";\n";
										j++;
									}
								}
							}else if(startTime.getTime()<=subStrDate.getTime()){
								if(expireTime.getTime()>=subStrDate.getTime()){
									if(expireTime.getTime()>=subExpDate.getTime()){
										//Possibility 4
										vldP = false;
										errMsg += "Conflict "+j+", type 4: You have already purchased from "+startTime+" to "+expireTime+";\n";
										j++;
									}else{
										//Possibility 5
										vldP = false;
										errMsg += "Fail Reason 8:You have already purchased from "+startTime+" to "+expireTime+";\n";
										errMsg += "Conflict "+j+", type 5: You have already purchased from "+startTime+" to "+expireTime+";\n";
										j++;
									}
								}else{
									//Possibility 6
								}
							}
						}
						
						if(vldP){
							errMsg = "Purchase Success";
							sql = "insert into purchaseinfo(section,userID,starttime,expiretime) values(?,?,?,?)";
							prepStmt = conn.prepareStatement(sql);
							prepStmt.setString(1, section);
							prepStmt.setString(2, userID);
							prepStmt.setString(3, startdate);
							prepStmt.setString(4, expiredate);
							prepStmt.executeUpdate();
							
							curDate=new Date();	//get current time
							int[] priv = new int[secNum];	//record the privilege of each section
							int privsum = 0;	//the total privilege
							
							/*
							 * generate and run sql sentence to get all user's subscription by its ID
							 */
							sql = "select * from purchaseinfo where userID=?";
							prepStmt = conn.prepareStatement(sql);
							prepStmt.setString(1, userID);
							rsPurchase = prepStmt.executeQuery();
							
							/*
							 * get the section user has subscripted and its available time
							 * generate the current total privilege of reading
							 */
							while (rsPurchase.next()){
								String sec = rsPurchase.getString("section");
								startTime = rsPurchase.getDate("starttime");
								expireTime = rsPurchase.getDate("expiretime");
								//System.out.println(section+","+startTime+","+expireTime);
								if (startTime.getTime()<=curDate.getTime()&&curDate.getTime()<=expireTime.getTime()){
									int i;
									for (i=0;i<4;i++){
										if (sec.equals(String.valueOf(i+1))&&priv[i]==0){
											//if the user owns the section now, add its privilege
											privsum = (int) (privsum + Math.pow(2, i));
											priv[i]=1;
											
											//print the current information
											System.out.println("section "+sec+", from "+startTime+" to "+expireTime+", the current time is "+curDate+", the privilege sum is:"+privsum);
										}
									}
								}
							}
							
							//change the privilege to String and update the database
							String privilegeCateloge = String.valueOf(privsum);
							sql = "update userinfo set privilegeCateloge = ? where userID = ?";
							prepStmt = conn.prepareStatement(sql);
							prepStmt.setString(1, privilegeCateloge);
							prepStmt.setString(2, userID);
							prepStmt.executeUpdate();
							System.out.println("update privilege successfully.");						
							
							purchaseRes="purchaseSuc";
						}
					}
				}
				System.out.println(errMsg);
				HttpSession session = request.getSession();
				session.setAttribute("errMsg", errMsg);		
			}
		} catch (SQLException se) {
			se.printStackTrace();
		}
		return mapping.findForward(purchaseRes);		
	}
}